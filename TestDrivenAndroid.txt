    *================== TEST DRIVEN ANDROID ==================*


+====================== FUNDAMENTALS OF TDD ======================+

    == WHY QUALITY IS IMP ==
    -> Quality is free
    -> Var devices, os, envs
    -> PlayStore reflection of qual
        -> Bad reviews don't go away (Avoid L-shaped and C-Shaped, go for Inverted L)
        -> Successful apps put qual first

    == SD TRIANGLE ==
    Traditional : {TIME, FEATURE, MONEY} Pick any two
    TDD : {CAPITAL (TIME/MONEY), FEATURES, QUALITY} Pick any one along with Quality
        Works well with scrum
        Minimises Tech Debt

    == WHEN TESTING HAPPENS ==
    WATERFALL
        Analysis -> Design -> Implementation -> Test -> Rollout

    TDD
        Analysis -> Design -> Test -> Implementation -> Rollout

    == WHY TEST FIRST ==
        Qual too imp to save till the end
        Define what qual code is before writing any
            Stay Focused
            Know when complete

+====================== TESTING TRIANGLE ======================+

            = INSTRUMENTED =
          ==== INTEGRATION ====
       ========== UNIT ==========


+====================== BDD ======================+

    == WHY BDD ==
        Common lang along all disciplines : Business Analyst, Testers, Developers
        A way to communicate

    == History ==
        Comes from TDD
        Domain Specific Language (DSL)
        Convert english language sentences to executable tests

    == BDD Focus ==
        Where
        What to test
        How
        Name
        Failure

    == Principles ==
    Unit test names are full sentences
    As a [user] I want feature so that [benefit]
    Acceptance criteria in Given -> When -> Then syntax

    == Example ==
    As a user I want to search for plants so that I can see plants that meet my criteria
    Given : Plant Service Initialised
    When : Search for Red
    Then : Results contain RedBud

    == Principles of BDD ==
    Define Unit Test
    Make Test fail
    Implement feature
    Verify that the implementation makes the test succeed


+====================== PROJ STRUCT ======================+

test : Runs on Local JVM (More concerned with POJOs). Used for Unit Tests.
androidTest : Runs on Android Environment. Used for Integration and Instrumentation Tests.

+====================== BEST PRACTICES - DTOS, Interfaces, Layers ======================+

Class : Noun
Variables : Adjectives
Methods : Verbs

Create an object from a class
    -> Each class should do one thing, and do it well
    -> Avoid very long classes (Long classes hard to test and reuse)
    -> Avoid classes that blur layer

Interfaces : Contracts what a class will do
    -> Collection of method signatures
    -> Can be implemented by multiple classes
    -> Can be used as a var type, eg VariableType variableName = new ObjectType();

Data Transfer Object
    -> Noun class
    -> POJO
    -> Can easily transfer data across layers, without dependencies on those layers

Traditional Layers
    -> {OUTSIDE APP} Persistence Layer
    -> Data Access (DAO)
    -> Business Logic
    -> UI
    -> DTO

    +==============+  +==============+  +==============+  +==============+
    | SEARCH PLANT |  |              |  | SPECIMEN DAO |  |              |
    |   ACTIVITY   |  |              |  +==============+  |              |
    +==============+  |              |                    |              |
                      |              |  +==============+  |              |
    +==============+  |              |  |  PLANT DAO   |  |              |
    |  ADD PLANTS  |  | PLANTSERVICE |  +==============+  |  PERSISTENCE |
    |   ACTIVITY   |  |              |                    |              |
    +==============+  |              |  +==============+  |              |
                      |              |  |   USER DAO   |  |              |
                      |              |  +==============+  |              |
                      +==============+                    +==============+

    +====================================================================+
    |                           PLANT DTO                                |
    +====================================================================+

+====================== WHY INTERFACES ======================+

INTERFACE
    -> Contract for a class
    -> Contains method signatures
    -> Can be implemented by multiple classes
        eg, VarType varName = new ObjType();
    -> Separates Vars and Obj Types
    -> Polymorphism
        Var types tell what a methods you are able to call, obj type tells you
        what will happen when you call that method

WHY USE INTERFACES
    -> Flexible, future proof design
    -> WebService to JsonService example, where if calls were made using interface, we can easily switch to diff objs
        so long as both those objects implement the same interfaces

    -> Parallel work across layers using stubs

    -> Business Analyst : What a prog should do
    -> Devs : Write Tests
    -> QA, Devs, Autos : Run the tests

DTOs AND INTERFACES
    -> A DTO is often the return type of a fetch method and a parameter of an insert/update/delete methods
    -> If using Strings too often, are you using OOD properly?


+====================== MINIMISING IF TESTS ======================+

WHAT IS AN IF TEST:
    -> If test : A decision structure
    -> Can be written in one class
    -> Or, can simulate the same thing by using subclasses

COMPLICATED IF TEST NOTORIOUSLY HARD TO COVER WITH TESTS
    -> A sign that logic is in the wrong class
    -> Less future-proof design
    -> If tests make for longer classes
    -> Smaller, concise classes are easier to test

EXAMPLE

                    CAR {move()}
                          |
        ========================================
        |                 |                    |
  GASOLINE {move()}   ELECTRIC {move()}   HYBRID {move()}


    Instead of
    Car{
        move() {
            if (GASOLINE) {
                //gas move
            } else if (ELECTRIC) {
                // electric move
            } else if (HYBRID) {
                // hybrid move
            }
        }
    }

+====================== JUNIT SYNTAX ======================+

JUNIT FEATURES
    -> Fixtures
        --> Prerequisites setup and teardowns for running tests
    -> Test Suites
        --> Aggregate tests together
    -> Test Runners
        --> Runs JUnit Tests
        --> Can aggregate successes and failures for summary

+====================== JUNIT FEATURES ======================+

JUNIT TEST CLASSES
    -> Classes we're writing to verify that the tests pass
    -> Assert : Contains assert method
    -> TestCase : Defines fixtures to run tests
    -> TestResults : Aggregates the results of running the tests

+====================== TESTCASE ======================+

    -> setup()
    -> teardown()
    -> Other methods
        --> run()
        --> get/setName()
        --> createResult()
        --> countTestCases()

+====================== @Test ======================+

@Test
    -> Indicates that this method should be evaluated by JUnit
    -> Very frequently used
    -> Replaces testXxx() syntax of JUnit3
    -> @Test(timeout = ms): Time to wait, in milliseconds before declaring the test failed
    -> @Test(expected = ClassCastException.class) : When throwing an Exception for the test, successful result is
    expected

+====================== @Ignore ======================+

@Ignore
    -> Ignore this class for testing
    -> Use temporarily
    -> If a class is failing an entire unit test suite for a known reason, and you need a build to run

+====================== @Before ======================+

@Before
    -> Runs this before each test method
    -> Good for initialisations required for each test

@BeforeClass
    -> Run once before any method in test class runs (only runs one time)

+====================== @After ======================+

@After
    -> Run this after each test method
    -> Good for de-initialisation after each test
    -> Release any resources or memory usage

@AfterClass
    -> Run once, after all tests have finished

+====================== @RunWith and @Suite ======================+

@RunWith(Suite.class)
    -> Indicate that we want to run a suite of classes

@RunWith(Parameterized.class)
    -> Data-driven parameterized class

@RunWith(MockitoJUnitRunner.class):
    -> Initialise annotation-based @Mock Objects

@Suite.SuiteClasses({}):
    -> A comma-separated list of test classes to run

+====================== Design for Test ======================+

How designing for test makes for better overall design
    -> Componentize Classes
    -> Class Diagram

Easier to see large number of small classes than small number of large classes

See DesignForTestUML for reference

NetworkDAO might have a URL or URI (Univeral Resource Link/Indicator)

+====================== History of BDD ======================+

-> Emerged from TDD
    -> Advantages of TDD and OOD with a ubiquitous lang
        -> BA, QA, Developers communicate and understand each other
        -> From specification to example
        -> Autonomous teams break down organizational boundaries
-> Attributed to Dan North

+====================== Core Principles of BDD ======================+

ItsAllBehavior : Business and Technology should refer to the same system in the same way.
WheresTheBusinessValue : Any system should have an identified, verifiable value to business.
EnoughIsEnough : Up-front analysis, design, and planning all have diminishing returns.

Fits well with Scrum even though not a part of it

+====================== BDD Focus : 5Ws ======================+

Where to start
What to test
How much to test
What to name the test
Why a test fails

+====================== BDD's Relation to Specifications ======================+

BD is an integral part of technical documentation
    -> Business Analyst (BA) writes behaviors
        -> EG : As a [user] I want to [action] so  that [outcome]
Developers ask questions
These become examples
    -> Given [context/assumption], When [action], Then [expected result]
    -> Use words that have meaning to everyone
    -> Prefer the term "example" over "test"
    -> Unit test methods as sentences, usually beginning with verbs (Verbose method names)
Everyone has a vested interest in quality

+====================== Example of Design Doc (GIVEN,WHEN,THEN) ======================+
        === REQIUREMENT 100.0 : SEARCH FOR PLANTS ===
SCENARIO
    As a user interested in plants, I want to be able to search plants based on any part of the name : genus, species, cultivar or
    common name.

DEPENDENCIES
    Plant search data are available and accessible

ASSUMPTIONS
    Scientific names are stated in Latin
    Common names are stated in English

EXAMPLES
    1.1
        GIVEN a feed of plant data is available
        WHEN I search for "RedBud"
        THEN I should recieve at least one result with these attributes
            Genus : Cercis
            Species : Canadensis
            Common Name : Eastern Redbud
    1.2
        GIVEN a feed of plant data is available
        WHEN I search for "Hybrid Oak"
        THEN I should recieve at least one result with these attributes
            Genus : Quercus
            Species : ×benderi
            Common Name : Hybrid Oak
        AND I should recieve at least one result with these attributes
            Genus : Quercus
            Species : ×benderi
            Common Name : Hybrid Oak
    1.3
        GIVEN a feed of plant data is available
        WHEN I search for "asdhagljkdfhbjgnn"
        THEN I should recieve zero results

    /*
    Common givens among examples are good so we can create common subassemblies for mutliple
    tests.
    */

SIGNOFF

REVISION HISTORY

+====================== Asserts ======================+

assertEquals
    -> Verifies that two items are equal
    -> Overloaded for many primitive types (int, long, float, double), plus String
    -> Doubles and floats overloads include a Delta variable for acceptable diff to assist in floating point arithmetic

assertNotEquals
    similar to assertEquals but test true if the results are not equal

assertNull, assertNotNull
    -> Null reference : Is there an object assigned to this variable
       -> PlantDTO plant = null; // null ref
       -> PlantDTO plant = new PlantDTO(); // not a null ref
    -> assertNull
        Verifies that given object is null
            -> Caution! : try not to get in a habit of returning null from a method especially if it is the result of catching an
            exception.
    -> assertNotNull
        Verifies object is not null










